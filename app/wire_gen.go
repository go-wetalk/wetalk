// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package app

import (
	"appsrv/model"
	"appsrv/pkg/auth"
	"appsrv/pkg/bog"
	"appsrv/pkg/config"
	"appsrv/pkg/db"
	"appsrv/pkg/oss"
	"appsrv/pkg/out"
	"appsrv/pkg/runtime"
	"appsrv/schema"
	"appsrv/service"
	"github.com/go-pg/pg/v9"
	"github.com/kataras/hcaptcha"
	"github.com/kataras/muxie"
	"github.com/minio/minio-go/v6"
	"github.com/spf13/cast"
	"github.com/xeonx/timeago"
	"go.uber.org/zap"
	"golang.org/x/crypto/bcrypt"
	"net/http"
	"strings"
	"time"
)

// Injectors from announce.go:

func NewAnnounceController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	announce := &Announce{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return announce
}

// Injectors from comment.go:

func NewCommentController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	comment := &Comment{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return comment
}

// Injectors from notification.go:

func NewNotificationController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	notification := &Notification{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return notification
}

// Injectors from task.go:

func NewTaskController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	task := &Task{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return task
}

// Injectors from text.go:

func NewTextController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	text := &Text{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return text
}

// Injectors from topic.go:

func NewTopicController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	topic := &Topic{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return topic
}

// Injectors from user.go:

func NewUserController() runtime.Controller {
	pgDB := db.ProvideSingleton()
	logger := bog.ProvideSingleton()
	client := oss.ProvideSingleton()
	serverConfig := config.ProvideSingleton()
	user := &User{
		db:   pgDB,
		log:  logger,
		mc:   client,
		conf: serverConfig,
	}
	return user
}

// announce.go:

type Announce struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *Announce) RegisterRoute(m muxie.SubMux) {
	m.Handle("/announces", muxie.Methods().HandleFunc(http.MethodGet, v.AppList))
}

func (v Announce) List(w http.ResponseWriter, r *http.Request) {
	var as = []model.Announce{}
	_ = v.db.Model(&as).OrderExpr("seq DESC, id ASC").Select()
	muxie.Dispatch(w, muxie.JSON, &as)
}

func (v Announce) Create(w http.ResponseWriter, r *http.Request) {
	var in struct {
		Announce
	}
	err := muxie.Bind(r, muxie.JSON, &in)
	if err != nil {
		v.log.Error("Announce.Create", zap.Error(err))
		w.WriteHeader(400)
		return
	}

	err = v.db.Insert(&in.Announce)
	if err != nil {
		v.log.Error("Announce.Create", zap.Error(err))
		w.WriteHeader(500)
		return
	}

	w.WriteHeader(204)
}

func (v Announce) Delete(w http.ResponseWriter, r *http.Request) {
	var a model.Announce
	err := v.db.Model(&a).Where("id = ?", muxie.GetParam(w, "announceID")).First()
	if err != nil {
		w.WriteHeader(404)
		return
	}

	_, err = v.db.Model(&a).WherePK().Delete()
	if err != nil {
		v.log.Error("Announce.Delete", zap.Error(err))
	}
	w.WriteHeader(204)
}

func (v Announce) AppList(w http.ResponseWriter, r *http.Request) {
	t := time.Now()
	as := []model.Announce{}
	_ = v.db.Model(&as).Where("(show IS NULL OR show < ?) AND (hide IS NULL OR hide > ?)", t, t).OrderExpr("seq DESC, id ASC").Select()

	var raw = []struct {
		ID        uint
		Name      string
		Slot      uint8
		SlotID    uint
		SlotParam string
		Seq       int
		Logo      string
	}{}
	for _, a := range as {
		raw = append(raw, struct {
			ID        uint
			Name      string
			Slot      uint8
			SlotID    uint
			SlotParam string
			Seq       int
			Logo      string
		}{
			ID:        a.ID,
			Name:      a.Name,
			Slot:      a.Slot,
			SlotID:    a.SlotID,
			SlotParam: a.SlotParam,
			Seq:       a.Seq,
			Logo:      a.LogoLink(),
		})
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(raw))
}

// comment.go:

type Comment struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *Comment) RegisterRoute(m muxie.SubMux) {
	m.Handle("/comments", muxie.Methods().
		HandleFunc(http.MethodGet, v.ListByFilter).
		HandleFunc(http.MethodPost, v.CreateTopicComment))
}

// CreateTopicComment 发表帖子评论
func (v Comment) CreateTopicComment(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err(401, "您还没有登录，请先登录"))
		return
	}

	var input schema.TopicCommentCreation
	err = muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	if err = input.Validate(); err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	c, err := service.Comment.CreateTopicComment(v.db, u, input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(c))
}

func (v Comment) ListByFilter(w http.ResponseWriter, r *http.Request) {
	input := schema.CommentFilter{}
	input.TopicID = cast.ToUint(r.URL.Query().Get("tid"))
	input.Page = cast.ToInt(r.URL.Query().Get("p"))
	if input.Page < 1 {
		input.Page = 1
	}
	input.Size = cast.ToInt(r.URL.Query().Get("s"))
	if input.Size < 1 {
		input.Size = 20
	}

	cs, err := service.Comment.FindByFilterInput(v.db, input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(cs))
}

// notification.go:

type Notification struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *Notification) RegisterRoute(m muxie.SubMux) {
	m.Handle("/notifications", muxie.Methods().HandleFunc(http.MethodGet, v.List))
	m.Handle("/notifications/:notificationID", muxie.Methods().HandleFunc(http.MethodDelete, v.MarkRead))
}

func (v Notification) List(w http.ResponseWriter, r *http.Request) {
	input := schema.Paginate{}
	input.Size = cast.ToInt(r.URL.Query().Get("s"))
	if input.Size < 1 {
		input.Size = 20
	}
	input.Page = cast.ToInt(r.URL.Query().Get("p"))
	if input.Page < 1 {
		input.Page = 1
	}

	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	ret, err := service.Notification.FindForUser(v.db, &u, input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(ret))
}

func (v Notification) MarkRead(w http.ResponseWriter, r *http.Request) {
	notifyID := cast.ToUint(muxie.GetParam(w, "notificationID"))

	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	err = service.Notification.MarkAsRead(v.db, &u, notifyID)
	if err != nil {
		v.log.Error("notification.MarkRead", zap.Error(err))
	}
	muxie.Dispatch(w, muxie.JSON, out.Err(204, "操作成功"))
}

// task.go:

type Task struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *Task) RegisterRoute(m muxie.SubMux) {
	m.Handle("/tasks", muxie.Methods().
		HandleFunc(http.MethodGet, v.AppList))
	m.Handle("/tasks/:taskID/bonus", muxie.Methods().
		HandleFunc(http.MethodPost, v.AppTaskLogCreate))
}

func (v Task) List(w http.ResponseWriter, r *http.Request) {
	var ts = []model.Task{}
	_ = v.db.Model(&ts).Order("id ASC").Select()
	muxie.Dispatch(w, muxie.JSON, &ts)
}

func (v Task) Create(w http.ResponseWriter, r *http.Request) {
	var in struct {
		model.Task
	}
	err := muxie.Bind(r, muxie.JSON, &in)
	if err != nil {
		v.log.Error("Task.Create", zap.Error(err))
		w.WriteHeader(400)
		return
	}

	err = v.db.Insert(&in.Task)
	if err != nil {
		v.log.Error("Task.Create", zap.Error(err))
		w.WriteHeader(500)
		return
	}

	w.WriteHeader(204)
}

func (v Task) Update(w http.ResponseWriter, r *http.Request) {
	var in struct {
		Name    string
		Content string
	}
	err := muxie.Bind(r, muxie.JSON, &in)
	if err != nil {
		v.log.Error("Task.Update", zap.Error(err))
		w.WriteHeader(400)
		return
	}

	var t model.Task
	err = v.db.Model(&t).Where("id = ?", muxie.GetParam(w, "TaskID")).First()
	if err != nil {
		w.WriteHeader(404)
		return
	}

	_, err = v.db.Model(&t).WherePK().Set("name = ?", in.Name).Set("content = ?", in.Content).Update()
	if err != nil {
		v.log.Error("Task.Update", zap.Error(err))
		w.WriteHeader(500)
		return
	}

	w.WriteHeader(204)
}

func (v Task) Delete(w http.ResponseWriter, r *http.Request) {
	m := model.Task{}
	err := v.db.Model(&m).Where("id = ?", muxie.GetParam(w, "taskID")).First()
	if err == nil {
		_, err = v.db.Model(&m).WherePK().Delete()
		if err != nil {
			v.log.Error("Task.Delete", zap.Error(err))
			w.WriteHeader(500)
			return
		}
	}

	w.WriteHeader(204)
}

func (v Task) AppList(w http.ResponseWriter, r *http.Request) {
	ts := []model.Task{}
	now := time.Now()
	count, err := v.db.Model(&ts).
		Where("(\"begin\" IS NULL OR \"begin\" <= ?) AND (\"end\" IS NULL OR \"end\" >= ?)", now, now).
		Order("seq DESC").
		SelectAndCount()
	if err != nil {
		v.log.Error("Task.AppList", zap.Error(err))
	}

	var u model.User
	auth.GetUser(r, &u)

	type outItem struct {
		ID         uint
		Name       string
		Intro      string
		Button     bool // 按钮形式就表示已完成未领取
		StatusText string
	}

	var out2 = struct {
		Count int
		Page  int
		Data  []outItem
	}{
		Count: count,
		Page:  1,
		Data:  []outItem{},
	}
	for _, t := range ts {
		if t.AvailableTo(v.db, &u) != nil {
			continue
		}

		i := outItem{
			ID:         t.ID,
			Name:       t.Name,
			Intro:      t.Intro,
			Button:     t.Fulfilled(&u) && !t.Got(v.db, &u),
			StatusText: t.StatusText(v.db, &u),
		}
		out2.
			Data = append(out2.Data, i)
	}
	muxie.Dispatch(w, muxie.JSON, &out2)
}

func (v Task) AppTaskLogCreate(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		w.WriteHeader(401)
		return
	}

	var t model.Task
	kword := muxie.GetParam(w, "taskID")
	err = v.db.Model(&t).Where("id = ? or factor = ?", cast.ToInt(kword), kword).Order("id DESC").First()
	if err != nil {
		w.WriteHeader(404)
		return
	}

	if t.AvailableTo(v.db, &u) != nil {
		w.WriteHeader(404)
		return
	}

	if !t.Fulfilled(&u) {
		w.WriteHeader(http.StatusPreconditionFailed)
		return
	}

	if t.Got(v.db, &u) {
		w.WriteHeader(http.StatusConflict)
		return
	}

	_, err = t.Confirm(v.db, &u)
	if err != nil {
		v.log.Error("Task.AppTaskLogCreate", zap.Error(err), zap.Uint("TaskID", t.ID), zap.Uint("UserID", u.ID))
		w.WriteHeader(500)
		return
	}

	w.WriteHeader(204)
}

// text.go:

type Text struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *Text) RegisterRoute(m muxie.SubMux) {
	m.Handle("/texts/:textID", muxie.Methods().HandleFunc(http.MethodGet, v.AppView))
}

func (v Text) List(w http.ResponseWriter, r *http.Request) {
	var ts = []model.Text{}
	_ = v.db.Model(&ts).Order("id ASC").Select()
	muxie.Dispatch(w, muxie.JSON, &ts)
}

func (v Text) Create(w http.ResponseWriter, r *http.Request) {
	var in struct {
		model.Text
	}
	err := muxie.Bind(r, muxie.JSON, &in)
	if err != nil {
		v.log.Error("Text.Create", zap.Error(err))
		w.WriteHeader(400)
		return
	}

	err = v.db.Insert(&in.Text)
	if err != nil {
		v.log.Error("Text.Create", zap.Error(err))
		w.WriteHeader(500)
		return
	}

	w.WriteHeader(204)
}

func (v Text) Update(w http.ResponseWriter, r *http.Request) {
	var in struct {
		Name    string
		Content string
	}
	err := muxie.Bind(r, muxie.JSON, &in)
	if err != nil {
		v.log.Error("Text.Update", zap.Error(err))
		w.WriteHeader(400)
		return
	}

	var t model.Text
	err = v.db.Model(&t).Where("id = ?", muxie.GetParam(w, "textID")).First()
	if err != nil {
		w.WriteHeader(404)
		return
	}

	_, err = v.db.Model(&t).WherePK().Set("name = ?", in.Name).Set("content = ?", in.Content).Update()
	if err != nil {
		v.log.Error("Text.Update", zap.Error(err))
		w.WriteHeader(500)
		return
	}

	w.WriteHeader(204)
}

func (v Text) AppView(w http.ResponseWriter, r *http.Request) {
	var t model.Text
	textID := muxie.GetParam(w, "textID")
	err := v.db.Model(&t).Where("id = ? OR slot_name = ?", cast.ToUint(textID), textID).First()
	if err != nil {
		w.WriteHeader(404)
		return
	}

	var out2 struct {
		Name    string
		Content string
	}
	out2.
		Name = t.Name
	out2.
		Content = t.Content
	muxie.Dispatch(w, muxie.JSON, &out2)
}

// topic.go:

// Topic 话题
type Topic struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *Topic) RegisterRoute(m muxie.SubMux) {
	m.Handle("/topics", muxie.Methods().
		HandleFunc(http.MethodGet, v.List).
		HandleFunc(http.MethodPost, v.Create))

	m.Handle("/topics/:topicID", muxie.Methods().
		HandleFunc(http.MethodGet, v.Find))
}

// List 取出话题列表
func (v Topic) List(w http.ResponseWriter, r *http.Request) {
	input := schema.TopicListInput{}
	input.Size = cast.ToInt(r.URL.Query().Get("s"))
	if input.Size < 1 {
		input.Size = 20
	}
	input.Page = cast.ToInt(r.URL.Query().Get("p"))
	if input.Page < 1 {
		input.Page = 1
	}
	if t := r.URL.Query().Get("t"); t != "" {
		input.Tag = strings.TrimSpace(t)
	}

	ts, _ := service.Topic.ListWithRankByScore(v.db, input)
	muxie.Dispatch(w, muxie.JSON, out.Data(ts))
}

// Create 创建话题
func (v Topic) Create(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err401)
		return
	}

	var input schema.TopicCreateInput
	err = muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	input.Title = strings.TrimSpace(input.Title)
	input.Content = strings.TrimSpace(input.Content)
	if err = input.Validate(); err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	t, err := service.Topic.Create(v.db, u, input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(t))
}

// Find 查看话题详情
func (v Topic) Find(w http.ResponseWriter, r *http.Request) {
	topicID := cast.ToUint(muxie.GetParam(w, "topicID"))
	t, err := service.Topic.FindByID(v.db, topicID)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(t))
}

// user.go:

type User struct {
	db   *pg.DB
	log  *zap.Logger
	mc   *minio.Client
	conf *config.ServerConfig
}

func (v *User) RegisterRoute(m muxie.SubMux) {
	m.Handle("/users", muxie.Methods().HandleFunc(http.MethodPost, v.SignUp))
	m.Handle("/tokens", muxie.Methods().HandleFunc(http.MethodPost, v.Login))
	m.Handle("/status", muxie.Methods().HandleFunc(http.MethodGet, v.AppStatus))
	m.Handle("/users/:name", muxie.Methods().HandleFunc(http.MethodGet, v.ViewUserDetail))
	m.Handle("/profile", muxie.Methods().HandleFunc(http.MethodGet, v.ViewProfile))
	m.Handle("/profile/logo", muxie.Methods().HandleFunc(http.MethodPut, v.UpdateLogo))
	m.Handle("/profile/address", muxie.Methods().HandleFunc(http.MethodPut, v.UpdateAddress))
	m.Handle("/profile/social", muxie.Methods().HandleFunc(http.MethodPut, v.UpdateSocial))
	m.Handle("/profile/password", muxie.Methods().HandleFunc(http.MethodPut, v.UpdatePassword))
}

func (v *User) AppStatus(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		return
	}

	us := schema.UserStatus{
		ID:           u.ID,
		Name:         u.Name,
		Logo:         u.Logo,
		Gender:       u.Gender,
		Coin:         u.Coin,
		Created:      u.Created.Format("2006-01-02 15:04:05"),
		RoleList:     u.RoleKeys,
		UnreadNotify: u.UnreadNotify(v.db),
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(us))
}

func (v *User) SignUp(w http.ResponseWriter, r *http.Request) {
	var input schema.UserSignUpInput
	err := muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	if err = input.Validate(); err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err(400, err.Error()))
		return
	}

	if config.ProvideSingleton().HCaptcha.Enabled {
		hcc := hcaptcha.New(config.ProvideSingleton().HCaptcha.Secret)
		if resp := hcc.VerifyToken(input.Captcha); !resp.Success {
			muxie.Dispatch(w, muxie.JSON, out.Err(400, resp.ChallengeTS))
			return
		}
	}

	u, err := service.User{}.CreateWithInput(v.db, input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	token, err := auth.Token(u.ID, u.RoleKeys)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}

	var raw struct {
		Token string
		User  schema.UserStatus
	}
	raw.Token = token
	raw.User.ID = u.ID
	raw.User.Name = u.Name
	raw.User.Logo = u.Logo
	raw.User.Gender = u.Gender
	raw.User.Created = u.Created.Format("2006-01-02 15:04:05")
	raw.User.RoleList = u.RoleKeys
	raw.User.UnreadNotify = u.UnreadNotify(v.db)
	muxie.Dispatch(w, muxie.JSON, out.Data(raw))
}

func (v *User) Login(w http.ResponseWriter, r *http.Request) {
	var input schema.UserSignUpInput
	err := muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	if err = input.Validate(); err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err(400, err.Error()))
		return
	}

	u, err := service.User{}.FindWithCredential(v.db, input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	token, err := auth.Token(u.ID, u.RoleKeys)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}

	var raw struct {
		Token string
		User  schema.UserStatus
	}
	raw.Token = token
	raw.User.ID = u.ID
	raw.User.Name = u.Name
	raw.User.Logo = u.Logo
	raw.User.Gender = u.Gender
	raw.User.Created = u.Created.Format("2006-01-02 15:04:05")
	raw.User.RoleList = u.RoleKeys
	raw.User.UnreadNotify = u.UnreadNotify(v.db)
	muxie.Dispatch(w, muxie.JSON, out.Data(raw))
}

func (v *User) ViewUserDetail(w http.ResponseWriter, r *http.Request) {
	name := muxie.GetParam(w, "name")
	u, err := service.User{}.FindByName(v.db, strings.TrimSpace(name))
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, err)
		return
	}

	raw := schema.UserDetail{}
	raw.ID = u.ID
	raw.Name = u.Name
	raw.Logo = u.LogoLink()
	raw.Created = timeago.Chinese.Format(u.Created)
	muxie.Dispatch(w, muxie.JSON, out.Data(raw))
}

func (v *User) ViewProfile(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err401)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(u))
}

func (v *User) UpdateLogo(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err401)
		return
	}

	f, h, err := r.FormFile("logo")
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	objectPath := time.Now().Format("20060102") + "/" + h.Filename

	_, err = v.mc.PutObject(v.conf.Oss.Bucket, objectPath, f, h.Size, minio.PutObjectOptions{
		ContentType: h.Header.Get("Content-Type"),
	})
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}

	_, err = v.db.Model(&u).WherePK().Set("logo_path = ?", objectPath).Update()
	if err != nil {
		v.log.Error(err.Error(), zap.Error(err))
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(nil))
}

func (v *User) UpdateAddress(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err401)
		return
	}

	input := schema.UserAddress{}
	err = muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	_, err = v.db.Model(&u).WherePK().
		Set("country = ?, province = ?, city = ?, street = ?", input.Country, input.Province, input.City, input.Street).
		Update()
	if err != nil {
		v.log.Error(err.Error(), zap.Error(err))
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(nil))
}

func (v *User) UpdateSocial(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err401)
		return
	}

	input := schema.UserSocial{}
	err = muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	_, err = v.db.Model(&u).WherePK().
		Set("sign = ?", input.Sign).
		Update()
	if err != nil {
		v.log.Error(err.Error(), zap.Error(err))
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(nil))
}

func (v *User) UpdatePassword(w http.ResponseWriter, r *http.Request) {
	var u model.User
	err := auth.GetUser(r, &u)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err401)
		return
	}

	input := schema.UserPassword{}
	err = muxie.Bind(r, muxie.JSON, &input)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.ErrBodyBind)
		return
	}

	err = bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(input.Original))
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err(400, "原始密码错误"))
		return
	}

	b, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		muxie.Dispatch(w, muxie.JSON, out.Err(500, "密码修改失败"))
		return
	}

	_, err = v.db.Model(&u).WherePK().
		Set("password = ?", string(b)).
		Update()
	if err != nil {
		v.log.Error(err.Error(), zap.Error(err))
		muxie.Dispatch(w, muxie.JSON, out.Err500)
		return
	}
	muxie.Dispatch(w, muxie.JSON, out.Data(nil))
}
